---
title: "Spotify Top Streamed Songs Analysis 2017 - 2019"
output: html_document
---
Group: 313A
 
Names: Danny Soulas, Laura Dinh, Torrey Coan, Nicholas Tam 

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo=TRUE, message=FALSE, warning = FALSE,
                      cache=TRUE, autodep=TRUE, cache.comments=FALSE)
library(tidyverse)
library(scales)
library(modelr)
library(tidymodels)
library(kableExtra)
source("../scripts/viridis.R")
source("../scripts/ggprob.R")
```


```{r, echo=FALSE, include=FALSE}
songs_2017 = read_csv("spotify-2017.csv") %>% mutate(charting_yr = 2017, rank = 1:100) 
songs_2018 = read_csv("spotify-2018.csv") %>% mutate(charting_yr = 2018, rank = 1:100)
songs_2019 = read_csv("spotify-2019.csv") %>% mutate(charting_yr = 2019, rank = 1:50)

all_songs = rbind(songs_2017,songs_2018,songs_2019)
```

## Introduction

Spotify is one of the most widely used streaming apps in the world with over 381 million users. It is used daily for users to enjoy their music, podcasts, and other forms of audio entertainment. For the purposes of our project, we will focus on Spotify music. The platform has collected data from its millions of users to determine the most popular streamed songs each year. In our project, we use playlists containing these top streamed songs over the course of three years. **These playlists generated by Spotify led us to seek questions about the data; can we discover a relationship between the variables of valence, tempo, and rank?** These songs can rack up over billions of streams, but what makes these songs so appealing? Do specific traits affect a song's overall rank? We wanted to discover if there were any meaningful relationships between variables in the dataset, specifically between valence, tempo, and rank. More specifically, we were interested in these questions:

- Did the tempo of top streamed songs get faster from 2017 to 2019?
- Did the top streamed songs get happier from 2017 to 2019?
- Can tempo and valence predict rank for the top streamed songs?


Although it may seem songs have gotten faster and happier in the past few years, we did not find any statistically significant evidence that the tempo and happiness of songs have increased from 2017 to 2019. In addition, we failed to find evidence significant enough between valence and rank to predict ranks, however there was evidence to show that the slope of the linear relationship between tempo and ranking is not 0 which can be used as a weak predictor for ranking. 

## Background

### About the Data

The Spotify Top Streamed 2017, 2018, and 2019 sets used were created by Nadin Tamer. The data was created by using [the Organize Your Music website](http://organizeyourmusic.playlistmachinery.com/)^[Organize Your Music: (http://organizeyourmusic.playlistmachinery.com/)], a web app that allows users to break down different characteristics of their music consumption. It intakes a Spotify playlist and returns scores of certain variables for each song. Playlists containing the top streamed songs from 2017, 2018, and 2019 were input into the Organize Your Music website and created data sets for each playlist. For each year's data set, each row is one song, each ordered from lowest ranked to highest rank. The Top Streamed Songs playlists from 2017 and 2018 had 100 songs each while 2019 had 50 songs. Therefore, the data set we used for our project has a total of 250 songs. However, let it be noted that there are 10 songs that appear twice in the data set. This is because there are 7 songs included in both 2017 and 2018, and 3 songs included in 2018 and 2019. We decided to keep these songs in the data sets because they were statistically significant and gave more representation for each year the data was in. We are also assuming that the data sets for each year are independent. In other words, the top streamed songs from one year do not affect the top streamed songs for the other years.


The data sets were uploaded to Kaggle by Nadin Tamer. Here are the links to the three data sets:

- [The Top Streamed Songs for 2017](https://www.kaggle.com/nadintamer/top-tracks-of-2017)^[Dataset for 2017: (https://www.kaggle.com/nadintamer/top-tracks-of-2017)]
- [The Top Streamed Songs for 2018](https://www.kaggle.com/nadintamer/top-spotify-tracks-of-2018)^[Dataset for 2018: (https://www.kaggle.com/nadintamer/top-spotify-tracks-of-2018)]
- [The Top Streamed Songs for 2019](https://www.kaggle.com/nadintamer/top-spotify-tracks-of-2019)^[Dataset for 2019: (https://www.kaggle.com/nadintamer/top-spotify-tracks-of-2019)]

From these data sets, we specifically examined three variables from the data sets: tempo, valence, and rank. 

Tempo is the speed or pace of a given song that is measured in beats per minute. Here are a few tempo indicators that demonstrate the typical tempo range of songs:



```{r, echo=FALSE}
song_variables = tibble(
  Description = c("Slow and Solemn", "Slowly", "Broadly", "Slow (at ease)", "Rather Slow", "Walking Pace", "Moderate", "Moderately Fast", "Fast, Quickly, and Bright", "Lively and Fast", "Extremely Fast", "Even Faster "),
  BPM = c("20–40 BPM", "40–45 BPM", "45–50 BPM", "55–65 BPM", "65–69 BPM", "73–77 BPM", "86–97 BPM", "98–109 BPM", "109–132 BPM", "132–140 BPM", "168–177 BPM", "178 BPM and over"))

song_variables %>% 
  kable(caption = "Tempo Ranges") %>% 
  kable_styling(position = "left", full_width = FALSE,
                bootstrap_options = c("striped"))
```


For more about tempo indicators [click here](https://symphonynovascotia.ca/faqs/symphony-101/how-do-musicians-know-how-fast-to-play-a-piece-and-why-are-the-terms-in-italian/)^[Tempo Definitions: (https://symphonynovascotia.ca/faqs/symphony-101/how-do-musicians-know-how-fast-to-play-a-piece-and-why-are-the-terms-in-italian/)]

Valence is specific to Spotify's API. It describes the musical positiveness conveyed by a track and is measure on a scale of 0 to 1. Tracks with a higher valence sound more positive while tracks with lower valence sound more sad. 

For more information about valence, here are links that provide more information: 

- [Valence Definition](https://www.theverge.com/tldr/2018/2/5/16974194/spotify-recommendation-algorithm-playlist-hack-nelson)^[Term Definitions: (https://www.theverge.com/tldr/2018/2/5/16974194/spotify-recommendation-algorithm-playlist-hack-nelson)]
- [How a Computer Determines Valence](https://web.archive.org/web/20170422195736/http://blog.echonest.com/post/66097438564/plotting-musics-emotional-valence-1950-2013)^[Where valence comes from: (https://web.archive.org/web/20170422195736/http://blog.echonest.com/post/66097438564/plotting-musics-emotional-valence-1950-2013)]

To conclude, rank represents how many streams a song has. A rank of 1 means the song was the top streamed song for the given year, a rank of 2 means the song was the second top streamed song for the given year, and so on. Therefore, lower rank means greater number of streams, and conversely, higher rank means lower number of streams.

###  Methods

In the rest of this report, we will be running unpaired two-sample T tests and creating linear regression models to examine the trends of valence and rank across the three years. 


#### Variables from Data

```{r, echo=FALSE}

#VARIABLES

song_variables = tibble(
  Name = c("name", "artists","valence", "tempo", "rank"),
  Description = c("A string of the song name",
                  "A string of the artist(s)' name(s)",
                  "A real number between 0 and 1 that represents the happiness of a song",
                  "A real number greater than or equal to 0 that represents the speed at which a passage of music is played. It is measured in beats per minute (BPM)",
                  "The popularity of the song for the year"))

song_variables %>% 
  kable(caption = "Key Variables from the Spotify Top Streamed Songs Data") %>% 
  kable_styling(position = "left", full_width = FALSE,
                bootstrap_options = c("striped"))

```


## Analysis

### Did the top streamed songs get faster from 2017 to 2019?

First, we summarize the tempo data for all three years. 

```{r, echo=FALSE}

#SUMMARIZE TEMPO DATA

tempo_2017 = songs_2017 %>% 
  select(tempo) %>% 
  summarize(n = n(),mean = mean(tempo), sd = sd(tempo), max = max(tempo), min = min(tempo))

tempo_2018 = songs_2018 %>% 
  select(tempo) %>% 
  summarize(n = n(),mean = mean(tempo), sd = sd(tempo), max = max(tempo), min = min(tempo))

tempo_2019 = songs_2019 %>% 
  select(tempo) %>% 
  summarize(n = n(),mean = mean(tempo), sd = sd(tempo), max = max(tempo), min = min(tempo))

tempo = bind_rows(tempo_2017, tempo_2018, tempo_2019)

years = tibble(
  year = c(2017, 2018, 2019)
)

bind_cols(years, tempo) %>% 
  kable(caption = "Tempo Summary") %>% 
  kable_styling(position = "left", full_width = FALSE,
                bootstrap_options = c("striped"))
```

- $year$ is the year the songs charted in the Spotify top streamed songs
- $n$ is the number of songs
- $mean$ is the mean tempo for the given year
- $sd$ is the standard deviation of the songs' tempo
- $max$ is the song with the fastest tempo for the year
- $min$ is the song with the slowest tempo for the year

#### T Tests

We ran an unpaired two-sample T Test (Two Mean Test) of tempos between 2017 and 2018:


```{r, echo=FALSE}

#PREP FOR: T TEST: TEMPO 2017 2018

# combine tempo for 2017 and 2019
tempo_data_17 = songs_2017 %>% 
  select(tempo, rank) %>% 
  mutate(year = "2017")

tempo_data_18 = songs_2018 %>% 
  select(tempo, rank) %>% 
  mutate(year = "2018")

tempo_data = bind_rows(tempo_data_17, tempo_data_18)

tempo_wide = tempo_data %>% 
  pivot_wider(names_from = year, values_from = tempo)

head(tempo_wide, 5) %>% 
  kable(caption = "Tempo between 2017 and 2018 for Top 5 Songs") %>% 
  kable_styling(position = "left", full_width = FALSE,
                bootstrap_options = c("striped"))
```



```{r, echo=FALSE, fig.cap = "**Mean Tempos for Top Songs (2017, 2018)**. The black dots represent the tempos of the songs."}

#BOXPLOT: TEMPO 2017 2018

ggplot(tempo_data, aes(x = year, y = tempo, fill = year)) +
  geom_boxplot(coef = Inf, alpha = 0.5) +
  geom_point(position = position_jitter(width=0.3, height=0)) +
  scale_fill_manual(values = c("purple", "darkgreen")) +
  xlab("Year") +
  ylab("Tempo") +
  ggtitle("Tempos in the Top Streamed Songs of 2017 and 2018") +
  theme_minimal() 
```

##### Model

We have two independent samples of songs, one for 2017 and the other for 2018

- $X_i \sim F_1(\mu_1, \sigma_1), \quad i = 1, \ldots, n_1$    
- $Y_i \sim F_2(\mu_2, \sigma_2), \quad i = 1, \ldots, n_2$   


##### Hypothesis Test

$$
H_0: \mu_1 = \mu_2 \\
H_a: \mu_1 < \mu_2
$$

##### Summary of the T-Test:
```{r, echo=FALSE}

#T TEST: TEMPO 2017 2018

x = tempo_data %>% 
  filter(year == "2017") %>% 
  pull(tempo)

y = tempo_data %>% 
  filter(year == "2018") %>% 
  pull(tempo)

stats = t.test(x, y, alternative = "less") 

results = tibble(
  mean_2017 = stats$estimate[1],
  mean_2018 = stats$estimate[2],
  t = stats$statistic,
  df = stats$parameter[1],
  pvalue = stats$p.value
)

results %>% 
  kable(caption = "Unpaired T Test Results") %>% 
  kable_styling(position = "left", full_width = FALSE,
                bootstrap_options = c("striped"))

```

We have no evidence from the data that the mean tempo for the top streamed songs of 2017 is different than the mean tempo for the top streamed songs of 2018 (p = 0.431, unpaired t-test, df = 197.825)

Let's run the same unpaired t-test for 2018 and 2019:


```{r, echo=FALSE}

#PREP FOR: T TEST: TEMPO 2018 2019

tempo_data_19 = songs_2019 %>% 
  select(tempo, rank) %>% 
  mutate(year = "2019")

tempo_data = bind_rows(tempo_data_18, tempo_data_19)

tempo_wide = tempo_data %>% 
  pivot_wider(names_from = year, values_from = tempo)

head(tempo_wide, 5) %>% 
  kable(caption = "Tempo between 2018 and 2019 for Top 5 Songs") %>% 
  kable_styling(position = "left", full_width = FALSE,
                bootstrap_options = c("striped"))
```



```{r, echo=FALSE, fig.cap = "**Mean Tempos for Top Songs (2018, 2019)**. The black dots represent the tempos of the songs."}

#BOXPLOT: T TEST: TEMPO 2018 2019

ggplot(tempo_data, aes(x = year, y = tempo, fill = year)) +
  geom_boxplot(coef = Inf, alpha = 0.5) +
  geom_point(position = position_jitter(width=0.3, height=0)) +
  scale_fill_manual(values = c("darkgreen", "red")) +
  xlab("Year") +
  ylab("Tempo") +
  ggtitle("Tempos in the Top Streamed Songs of 2018 and 2019") +
  theme_minimal() 
```

##### Model

- $X_i \sim F_1(\mu_1, \sigma_1), \quad i = 1, \ldots, n_1$    
- $Y_i \sim F_2(\mu_2, \sigma_2), \quad i = 1, \ldots, n_2$   


##### Hypothesis Test

$$
H_0: \mu_1 = \mu_2 \\
H_a: \mu_1 < \mu_2
$$

##### Summary of the T-Test:
```{r, echo=FALSE}

#T TEST: TEMPO 2018 2019

x = tempo_data %>% 
  filter(year == "2018") %>% 
  pull(tempo)

y = tempo_data %>% 
  filter(year == "2019") %>% 
  pull(tempo)

stats = t.test(x, y, alternative = "less") 

results = tibble(
  mean_2018 = stats$estimate[1],
  mean_2019 = stats$estimate[2],
  t = stats$statistic,
  df = stats$parameter[1],
  pvalue = stats$p.value
)

results %>% 
  kable(caption = "Unpaired T Test Results") %>% 
  kable_styling(position = "left", full_width = FALSE,
                bootstrap_options = c("striped"))

```

We have no evidence from the data that the mean tempo for the top streamed songs of 2018 is different than the mean tempo for the top streamed songs of 2019 (p = 0.458, unpaired t-test, df = 98.278)

Lastly, let's check if there is a difference between the means for 2017 and 2019:

```{r, echo=FALSE}

#PREP FOR: T TEST: TEMPO 2017 2019

tempo_data = bind_rows(tempo_data_17, tempo_data_19)

tempo_wide = tempo_data %>% 
  pivot_wider(names_from = year, values_from = tempo)

head(tempo_wide, 5) %>% 
  kable(caption = "Tempo between 2017 and 2019 for Top 5 Songs") %>% 
  kable_styling(position = "left", full_width = FALSE,
                bootstrap_options = c("striped"))
```

```{r, echo=FALSE, fig.cap = "**Mean Tempos for Top Songs (2017, 2019)**. The black dots represent the tempos of the songs."}

#BOXPLOT: T TEST: TEMPO 2017 2019

ggplot(tempo_data, aes(x = year, y = tempo, fill = year)) +
  geom_boxplot(coef = Inf, alpha = 0.5) +
  geom_point(position = position_jitter(width=0.3, height=0)) +
  scale_fill_manual(values = c("purple", "red")) +
  xlab("Year") +
  ylab("Tempo") +
  ggtitle("Tempos in the Top Streamed Songs of 2017 and 2019") +
  theme_minimal() 

```

##### Model

- $X_i \sim F_1(\mu_1, \sigma_1), \quad i = 1, \ldots, n_1$    
- $Y_i \sim F_2(\mu_2, \sigma_2), \quad i = 1, \ldots, n_2$   

##### Hypothesis Test

$$
H_0: \mu_1 = \mu_2 \\
H_a: \mu_1 < \mu_2
$$

##### Summary of the T-Test:
```{r, echo=FALSE}

#T TEST: TEMPO 2017 2019

x = tempo_data %>% 
  filter(year == "2017") %>% 
  pull(tempo)

y = tempo_data %>% 
  filter(year == "2019") %>% 
  pull(tempo)

stats = t.test(x, y, alternative = "less") 

results = tibble(
  mean_2017 = stats$estimate[1],
  mean_2019 = stats$estimate[2],
  t = stats$statistic,
  df = stats$parameter[1],
  pvalue = stats$p.value
)

results %>% 
  kable(caption = "Unpaired T Test Results") %>% 
  kable_styling(position = "left", full_width = FALSE,
                bootstrap_options = c("striped"))

```

We have no evidence from the data that the mean tempo for the top streamed songs of 2017 is different than the mean tempo for the top streamed songs of 2019 (p = 0.402, unpaired t-test, df = 95.713)

#### Correlations

Can tempo predict rank for a top streamed song in the 2017 to 2019 data?

```{r, echo=FALSE, fig.cap = "The black dots represent the tempos of the songs. The blue line is a fitted linear model"}

#CORRELATION: TEMPO AND RANK

# compares rank vs tempo for the three separate years
ggplot(all_songs, aes(tempo, rank)) +
  facet_wrap(~ charting_yr)+
  geom_point() +
  geom_smooth(method = "lm", se = FALSE) +
  ggtitle("Tempo vs. Rank: 2017-2019")+xlab("Tempo")+ylab("Rank")

corr_2017 = cor(songs_2017$tempo, songs_2017$rank)

corr_2018 = cor(songs_2018$tempo, songs_2018$rank)

corr_2019 = cor(songs_2019$tempo, songs_2019$rank)

corr_all = cor(all_songs$tempo, all_songs$rank)
```

For each year the correlations were:

- 2017: $r$ = 0.100
- 2018: $r$ = 0.179
- 2019: $r$ = 0.170

The correlation for all top streamed songs from 2017-2019:

- $r$ = 0.127


#### Linear Regression

It looks like there may be a relationship between the two - let's find the linear regression model using tempo to estimate rank, and see the significance of tempo as a predictor. 

##### Hypothesis Test

Let $B_1$ be the slope of the linear regression model between tempo and rank.

$$
H_0: B_1 =  0 \\
H_a: B_1 \ne 0
$$

```{r, echo = FALSE, fig.cap = "This graph plots all the top streamed songs from 2017, 2018 and 2019. The black dots represent a single song. The blue line represents a fitted linear model"}

#LIN REGRESSION: TEMPO FOR RANK

all_songs_t = all_songs 

ggplot(all_songs_t, mapping = aes(x = tempo, y = rank))+
  geom_point()+
  geom_smooth(method = "lm", se = FALSE)+
  ggtitle("Linear Regression on Tempo for Rank: 2017-2019")+
  xlab("Tempo")+ylab("Rank")
```

```{r,echo=FALSE}

#95% CI of the regression model on tempo
## tidymodels fit of the regression model
tempo_lm = linear_reg() %>% 
  set_engine("lm") %>% 
  fit(rank ~ tempo, data = all_songs_t)

## extracting a summary table of coefficients and inference values
tempo_lm_sum = tidy(tempo_lm)

#tempo_lm_sum

## a one-line summary of the fitted model
tempo_lm_glance = glance(tempo_lm)
tempo_lm_glance %>% select(p.value) %>% kable(caption = "Linear Regression P-Value") %>% 
  kable_styling(position = "left", full_width = FALSE,
                bootstrap_options = c("striped"))


## augment residuals and predicted values
tempo_aug = tempo_lm %>% 
  augment(all_songs_t)

df_lm1 = lm(rank ~ tempo, data = all_songs_t)
coef1 = coef(df_lm1)
t1 = tibble(intercept = coef1[1], b1 = coef1[2], regression_on = "tempo")

t1 %>% kable(caption = "Linear Regression Summary") %>% 
  kable_styling(position = "left", full_width = FALSE,
                bootstrap_options = c("striped"))

```

With a p-value = 0.046 < 0.05, we reject the null hypothesis and have evidence to support the alternative that the true slope between tempo and rank is nonzero. We have evidence that tempo is a statistically significant predictor of rank. 


### Did the top streamed songs get happier from 2017 to 2019?

Now, we'll summarize the valence data for all three years. 

```{r, echo=FALSE}

#SUMMARIZE VALENCE

valence_2017 = songs_2017 %>% 
  select(valence) %>% 
  summarize(n = n(),mean = mean(valence), sd = sd(valence), max = max(valence), min = min(valence))

valence_2018 = songs_2018 %>% 
  select(valence) %>% 
  summarize(n = n(),mean = mean(valence), sd = sd(valence), max = max(valence), min = min(valence))

valence_2019 = songs_2019 %>% 
  select(valence) %>% 
  summarize(n = n(),mean = mean(valence), sd = sd(valence), max = max(valence), min = min(valence))

valence = bind_rows(valence_2017, valence_2018, valence_2019)

years = tibble(
  year = c(2017, 2018, 2019)
)

bind_cols(years, valence) %>% 
  kable(caption = "Valence Summary") %>% 
  kable_styling(position = "left", full_width = FALSE,
                bootstrap_options = c("striped"))
```

- $year$ is the year the songs are from
- $n$ is the number of songs
- $mean$ is the mean valence for the given year
- $sd$ is the standard deviation of the songs' valence
- $max$ is the song with the highest valence for the year
- $min$ is the song with the lowest valence for the year

From the table, we can see that the mean actually decreased between all three years.

#### T Tests

We ran an unpaired two-sample T Test of valences between 2017 and 2018:


```{r, echo=FALSE}

#PREP FOR: T TEST: VALENCE 2017 2018

# combine valence for 2017 and 2018
valence_data_17 = songs_2017 %>% 
  select(valence, rank) %>% 
  mutate(year = "2017")

valence_data_18 = songs_2018 %>% 
  select(valence, rank) %>% 
  mutate(year = "2018")

valence_data = bind_rows(valence_data_17, valence_data_18)

valence_wide = valence_data %>% 
  pivot_wider(names_from = year, values_from = valence)

head(valence_wide, 5) %>% 
  kable(caption = "Valence between 2017 and 2018 for Top 5 Songs") %>% 
  kable_styling(position = "left", full_width = FALSE,
                bootstrap_options = c("striped"))
```



```{r, echo=FALSE, fig.cap = "**Mean Valence for Top Songs (2017, 2018)**. The black dots represent the valence for each of the songs."}

#BOXPLOT: T TEST: VALENCE 2017 2018

ggplot(valence_data, aes(x = year, y = valence, fill = year)) +
  geom_boxplot(coef = Inf, alpha = 0.5) +
  geom_point(position = position_jitter(width=0.3, height=0)) +
  scale_fill_manual(values = c("purple", "darkgreen")) +
  xlab("Year") +
  ylab("Valence") +
  ggtitle("Valence in the Top Streamed Songs of 2017 and 2018") +
  theme_minimal() 

```

##### Model

- $X_i \sim F_1(\mu_1, \sigma_1), \quad i = 1, \ldots, n_1$    
- $Y_i \sim F_2(\mu_2, \sigma_2), \quad i = 1, \ldots, n_2$   


##### Hypothesis Test

$$
H_0: \mu_1 = \mu_2 \\
H_a: \mu_1 < \mu_2
$$

##### Summary of the T-Test:
```{r, echo=FALSE, fig.cap = "**Mean Valence for Top Songs (2018, 2019)**. The black dots represent the valence for each of the songs."}

#T TEST: VALENCE 2017 2018

x = valence_data %>% 
  filter(year == "2017") %>% 
  pull(valence)

y = valence_data %>% 
  filter(year == "2018") %>% 
  pull(valence)

stats = t.test(x, y, alternative = "less") 

results = tibble(
  mean_2017 = stats$estimate[1],
  mean_2018 = stats$estimate[2],
  t = stats$statistic,
  df = stats$parameter[1],
  pvalue = stats$p.value
)

results %>% 
  kable(caption = "Unpaired T Test Results") %>% 
  kable_styling(position = "left", full_width = FALSE,
                bootstrap_options = c("striped"))

```

We have no evidence from the data that the mean valence for the top streamed songs of 2017 is different than the mean valence for the top streamed songs of 2018 (p = 0.862, unpaired t-test, df = 197.532)

Let's run the same unpaired t-test for 2018 and 2019:


```{r, echo=FALSE}

#PREP FOR: T TEST: VALENCE 2018 2019

valence_data_19 = songs_2019 %>% 
  select(valence, rank) %>% 
  mutate(year = "2019")

valence_data = bind_rows(valence_data_18, valence_data_19)

valence_wide = valence_data %>% 
  pivot_wider(names_from = year, values_from = valence)

head(valence_wide, 5) %>% 
  kable(caption = "Valence between 2018 and 2019 for Top 5 Songs") %>% 
  kable_styling(position = "left", full_width = FALSE,
                bootstrap_options = c("striped"))
```



```{r, echo=FALSE}

#BOXPLOT: VALENCE 2018 2019

ggplot(valence_data, aes(x = year, y = valence, fill = year)) +
  geom_boxplot(coef = Inf, alpha = 0.5) +
  geom_point(position = position_jitter(width=0.3, height=0)) +
  scale_fill_manual(values = c("darkgreen", "red")) +
  xlab("Year") +
  ylab("Valence") +
  ggtitle("Valence in the Top Streamed Songs of 2018 and 2019") +
  theme_minimal() 

```

##### Model

- $X_i \sim F_1(\mu_1, \sigma_1), \quad i = 1, \ldots, n_1$    
- $Y_i \sim F_2(\mu_2, \sigma_2), \quad i = 1, \ldots, n_2$   


##### Hypothesis Test

$$
H_0: \mu_1 = \mu_2 \\
H_a: \mu_1 < \mu_2
$$

##### Summary of the T-Test:
```{r, echo=FALSE}

#T TEST: VALENCE 2018 2019

x = valence_data %>% 
  filter(year == "2018") %>% 
  pull(valence)

y = valence_data %>% 
  filter(year == "2019") %>% 
  pull(valence)

stats = t.test(x, y, alternative = "less") 

results = tibble(
  mean_2018 = stats$estimate[1],
  mean_2019 = stats$estimate[2],
  t = stats$statistic,
  df = stats$parameter[1],
  pvalue = stats$p.value
)

results %>% 
  kable(caption = "Unpaired T Test Results") %>% 
  kable_styling(position = "left", full_width = FALSE,
                bootstrap_options = c("striped"))

```

We have no evidence from the data that the mean valence for the top streamed songs of 2018 is different than the mean valence for the top streamed songs of 2019 (p = 0.436, unpaired t-test, df = 92.946)

Lastly, let's check if there is a difference between the means for 2017 and 2019:

```{r, echo=FALSE}

#PREP FOR: T TEST: VALENCE 2017 2019

valence_data = bind_rows(valence_data_17, valence_data_19)

valence_wide = valence_data %>% 
  pivot_wider(names_from = year, values_from = valence)

head(valence_wide, 5) %>% 
  kable(caption = "Valence between 2017 and 2019 for Top 5 Songs") %>% 
  kable_styling(position = "left", full_width = FALSE,
                bootstrap_options = c("striped"))
```

```{r, echo=FALSE, fig.cap = "**Mean Valence for Top Songs (2017, 2019)**. The black dots represent the valence for each of the songs."}

#BOXPLOT: T TEST: VALENCE 2017 2019

ggplot(valence_data, aes(x = year, y = valence, fill = year)) +
  geom_boxplot(coef = Inf, alpha = 0.5) +
  geom_point(position = position_jitter(width=0.3, height=0)) +
  scale_fill_manual(values = c("purple", "red")) +
  xlab("Year") +
  ylab("Valence") +
  ggtitle("Valence in the Top Streamed Songs of 2017 and 2019") +
  theme_minimal() 

```

##### Model

- $X_i \sim F_1(\mu_1, \sigma_1), \quad i = 1, \ldots, n_1$    
- $Y_i \sim F_2(\mu_2, \sigma_2), \quad i = 1, \ldots, n_2$   


##### Hypothesis Test

$$
H_0: \mu_1 = \mu_2 \\
H_a: \mu_1 < \mu_2
$$

##### Summary of the T-Test:
```{r, echo=FALSE}

#T TEST: VALENCE 2017 2019

x = valence_data %>% 
  filter(year == "2017") %>% 
  pull(valence)

y = valence_data %>% 
  filter(year == "2019") %>% 
  pull(valence)

stats = t.test(x, y, alternative = "less") 

results = tibble(
  mean_2017 = stats$estimate[1],
  mean_2019 = stats$estimate[2],
  t = stats$statistic,
  df = stats$parameter[1],
  pvalue = stats$p.value
)

results %>% 
  kable(caption = "Unpaired T Test Results") %>% 
  kable_styling(position = "left", full_width = FALSE,
                bootstrap_options = c("striped"))

```

We have no evidence from the data that the mean valence for the top streamed songs of 2017 is different than the mean valence for the top streamed songs of 2019 (p = 0.758, unpaired t-test, df = 	97.029)


#### Correlations

Can valence predict rank for a top streamed song in the 2017 to 2019 data?

```{r, echo=FALSE, fig.cap = "The black dots represent the valence of the songs. The blue line is a fitted linear model"}
# compares rank vs tempo for the three separate years
ggplot(all_songs, aes(x = valence, y = rank)) +
  facet_wrap(~ charting_yr)+
  geom_point() +
  geom_smooth(method = "lm", se = FALSE) +
  ggtitle("Valence vs. Rank: 2017-2019")+xlab("Valence")+ylab("Rank")

corr_2017 = cor(songs_2017$valence, songs_2017$rank)
corr_2018 = cor(songs_2018$valence, songs_2018$rank)
corr_2019 = cor(songs_2019$valence, songs_2019$rank)

corr_all = cor(all_songs$valence, all_songs$rank)
```

For each year the correlations were:

- 2017: $r$ = -0.185
- 2018: $r$ = 0.013
- 2019: $r$ = -0.191

The correlation for all top streamed songs from 2017-2019:

- $r$ = -0.084


#### Linear Regression

Let's check to see if valence is a statistically significant predictor of rank using a linear regression model. 

##### Hypothesis Test

Let $B_1$ be the slope of the linear regression model between valence and rank.

$$
H_0: B_1 = 0 \\
H_a: B_1 \ne 0
$$


```{r, echo = FALSE, fig.cap = "This graph plots all the top streamed songs from 2017, 2018 and 2019. The black dots represent a single song. The blue line represents a fitted linear model"}

#LIN REGRESSION: VALENCE FOR RANK

ggplot(all_songs_t, mapping = aes(x = valence, y = rank))+
  geom_point()+
  geom_smooth(method = "lm", se = FALSE)+
  ggtitle("Linear Regression on Valence for Rank: 2017-2019")+
  xlab("Valence")+ylab("Rank")

```

```{r, echo=FALSE}

#95% CI of the regression model on tempo
## tidymodels fit of the regression model
tempo_lm = linear_reg() %>% 
  set_engine("lm") %>% 
  fit(rank ~ valence, data = all_songs_t)

## extracting a summary table of coefficients and inference values
tempo_lm_sum = tidy(tempo_lm)

## a one-line summary of the fitted model
tempo_lm_glance = glance(tempo_lm)
tempo_lm_glance %>% select(p.value) %>% kable(caption = "Linear Regression P-Value") %>% 
  kable_styling(position = "left", full_width = FALSE,
                bootstrap_options = c("striped"))


## augment residuals and predicted values
tempo_aug = tempo_lm %>% 
  augment(all_songs_t)

df_lm1 = lm(rank ~ valence, data = all_songs_t)
coef1 = coef(df_lm1)
t1 = tibble(intercept = coef1[1], b1 = coef1[2], regression_on = "valence")
t1 %>% kable(caption = "Linear Regression Summary") %>% 
  kable_styling(position = "left", full_width = FALSE,
                bootstrap_options = c("striped"))

```

With a p value = 0.18 > 0.05, we fail to reject the null hypothesis that a the linear regression model has a coefficient for valence of 0. 



## Discussion

At first glance, from the summary tables, there was an increasing trend for tempo across the three years. However, further assessing the variables through the graphing of side-by-side boxplots and unpaired t-test, we found no evidence that tempo or valence have increased from 2017-2019, and that the increase of both variables could have just been the result of noise. 

The average tempo of songs across the three years increased approximately 0.6 beats per minute faster for every year. After performing the unpaired two-sample t-tests, we found the p-values for each year were approximately 0.4. In other words, that this increase in the mean was not statistically significant. If we look at tempo indicators defined in the “about the data section,” we can see that the intervals of tempo indicators are much larger than 0.6 beats per minute. We would have to have a much larger jump between means for the increase to be statistically significant. 

In comparison, the average valence of songs did not increase like we expected and did not display any noticeable trends. All the p-values for the unpaired two-sample t tests were greater than 0.4, meaning there was no evidence that the mean valence increased between 2017 and 2018, 2018 and 2019, and 2017 to 2019.

For the relationship between tempo and rank, the correlation coefficients were very weak, approximately 0.1 for every year in our sample. However, the hypothesis test we performed showed that tempo and rank’s linear regression model had a slope that was nonzero. We can use the linear regression model to predict the rank based on the tempo; however, because the relationship is weak, the predictions may not be very accurate. To summarize, changes in tempo are associated with changes in rank, as the p-value for the coefficient of tempo (0.045) was beneath our threshold (0.05). This means it is unlikely our data could have occurred under the null hypothesis that the coefficient for tempo was 0. Per our linear regression, we see that for the top streamed Spotify songs from 2017-2019, if beats per minute increases by 1, we can expect rank to increase by about 0.13. 

The relationship between valence and rank did not have the same result. The correlation coefficients were very weak. Our hypothesis test found that there was no evidence that the slope of the linear regression line was not 0. Unless we significantly raise alpha, we should not use valence to estimate the rank of top streamed Spotify songs. Changes in valence are not associated with changes in rank, since the p-value associated with the coefficient of valence in the linear regression (p-value = 0.18) was greater than our threshold (alpha = 0.05). 

### Potential Shortcomings


#### Data accuracy

The data is directly extracted from the Spotify app and Spotify's official playlists. The data should be considered as accurate as possible. However, since some of the data is with regards to some variables that are harder to measure like valence, danceability and energy.

A music professional measured the valence of a sample of songs, applying a set of rules. To apply the same rules to all songs in Spotify’s library, Spotify used a machine learning algorithm to train on the sample songs and learn the rules set by the music professionals. This algorithm then applied these learned rules and applied them to all of the songs on Spotify. Even though there was only one person measuring valence, which reduced variability if multiple people were measuring songs, valence is still very subjective and ambiguous. It is unknown what rules the music professional used to measure songs. 


#### Missing key data

The dataset for year 2019 only consists of 50 of the top 100 songs. 
We would have had more accurate results if we were able to have the top 100.


#### Sample not representative

Since the 3 data sets used were from 2017 - 2019, the sample size could have been two small and the years are directly next to each other. Since the sample data set is limited, it may not be reasonable to compare the data obtained to years outside of the range since it would be using extrapolation, which could be inaccurate. Moreover, with Covid, music tastes could have changed since 2019 and our sample data when compared to years after could be inaccurate. 

#### Key assumptions may not hold

In our background, we assumed that the data sets were independent. The top streamed songs from one year did not affect the top streamed songs of the other two years. This assumption is not necessarily true. Some top songs are repeated across the three years. This means that the data from year to year is dependent and the unpaired two-sample t-tests that were run might not be entirely accurate. 

### Future Direction

In the future, the research could include more data and variables. Data from the lLaunch of Spotify can be collected on the top 1000 songs, and the songs could be split into different categories based on language or genre. Using these data sets, we can combine data into date ranges and potentially compare differences in music tastes across decades as opposed to individual years. Since we weren’t able to find any evidence with our current data set, using a larger data set could give us the evidence we need to find the correlation between tempo and rank or valence and rank. 

## Conclusion

In conclusion, we have found that there was no evidence that the tempo and happiness of songs have increased from 2017 to 2019. While the increase in the mean of tempo was not statistically significant, we did find that the tempo was a weak predictor of rank  within the top streamed songs of 2017, 2018, and 2019.


## References




